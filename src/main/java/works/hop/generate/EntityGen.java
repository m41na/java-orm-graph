package works.hop.generate;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import works.hop.orm.Col;
import works.hop.parser.EntityNode;
import works.hop.parser.FieldNode;
import works.hop.parser.Parser;
import works.hop.parser.Tokenizer;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static works.hop.generate.TypeResolver.resolve;
import static works.hop.orm.Schema.*;

public class EntityGen {

    public static void main(String[] args) {
        EntityGen gen = new EntityGen();
        try {
            gen.entities().values().forEach(node -> {
                try {
                    gen.generate(node);
                } catch (IOException | ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
            });
        } catch (IOException | URISyntaxException e) {
            throw new RuntimeException(e);
        }
    }

    public Map<String, EntityNode> entities() throws IOException, URISyntaxException {
        Tokenizer tk = new Tokenizer("mapping/mappers.ntt");
        tk.tokenize();
        Parser parser = new Parser(tk.tokens, "works.hop.entity");
        parser.parse();
        Map<String, EntityNode> entities = parser.getEntities();

        List<String> tables = orderedTables(DATA_TABLES);
        Collections.reverse(tables);
        for (String table : tables) {
            List<Col> cols = columns(table);
            EntityNode entityNode = entities.get(table);
            //skip columns that form a compound property
            List<String> skip = entityNode.getFields().values().stream().filter(c -> c.getColumn().contains(","))
                    .flatMap(c -> Arrays.stream(c.getColumn().split(","))).collect(Collectors.toList());
            for (Col col : cols) {
                if (!skip.contains(col.getName()) && !entityNode.getFields().containsKey(col.getName())) {
                    FieldNode fieldNode = new FieldNode(col.getName(), col.getName(), col.getType());
                    entityNode.getFields().put(col.getName(), fieldNode);
                }
            }
        }

        entities.forEach((k, v) -> System.out.printf("%s -> %s%n", k, v));
        return entities;
    }

    public void generate(EntityNode node) throws IOException, ClassNotFoundException {
        TypeSpec.Builder builder = TypeSpec.classBuilder(node.getName())
                .addSuperinterface(Entity.class)
                .addAnnotation(Data.class)
                .addAnnotation(AllArgsConstructor.class)
                .addAnnotation(NoArgsConstructor.class)
                .addModifiers(Modifier.PUBLIC);

        for (FieldNode field : node.getFields().values()) {
            FieldSpec fieldSpec = FieldSpec.builder(resolve(node.getNamespace(), field.getType()), field.getName())
                    .addModifiers(Modifier.PRIVATE)
                    .build();
            builder.addField(fieldSpec);
        }

        JavaFile javaFile = JavaFile.builder(node.getNamespace(), builder.build())
                .addFileComment("Autogenerated class. Do not modify")
                .build();

//        javaFile.writeTo(System.out);
        javaFile.writeTo(Paths.get("src/main/java"));
    }
}
